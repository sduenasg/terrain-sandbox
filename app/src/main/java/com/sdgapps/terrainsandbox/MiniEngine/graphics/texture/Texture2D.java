package com.sdgapps.terrainsandbox.MiniEngine.graphics.texture;

import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.opengl.GLES30;
import android.opengl.GLUtils;

import com.sdgapps.terrainsandbox.MiniEngine.graphics.Vec2f;
import com.sdgapps.terrainsandbox.utils.Logger;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class Texture2D extends Texture{

    public String path;

    /**
     * Android resource ID
     */
    private boolean needsPixels;
    private int[] pixels;
    private String[] pathList;
    private boolean preMultiplyAlpha = true;

    Texture2D(String path, boolean mipmap, boolean alpha, boolean _interpolation, boolean _wrapMode, boolean _needsPixels,boolean _premultiplyAlpha) {
        this.path = path;
        this.mipmapping = mipmap;
        this.alpha = alpha;
        this.interpolation = _interpolation;
        this.wrapMode = _wrapMode;
        needsPixels = _needsPixels;
        preMultiplyAlpha=_premultiplyAlpha;
    }

    private void getMipMapPaths(AssetManager am)
    {
        String[] files=null;
        try {
            files=am.list(path);
        } catch (IOException e) {
            e.printStackTrace();
        }

        mipmaplevels=files.length;
        pathList=new String[mipmaplevels];
        String[] tokens=files[0].split("_mip");
        String base=tokens[0].trim();

        String[] dotokens=files[0].split("[.]+");
        String extension="."+dotokens[dotokens.length-1].trim();

        if(extension.equals(".pkm"))
            compressionType=compression_ETC2;
        else
            compressionType=compression_NONE;

        for(int i=0;i<mipmaplevels;i++)
        {
            pathList[i]=path+"/"+base+"_mip_"+i+extension;
        }
    }

    private void getPathType()
    {
        pathType=0;
        String[] separate=path.split("[/]+");
        String last=separate[separate.length-1];
        if(last.contains("."))
            pathType=isfile;
        else
            pathType=isdirectory;

    }

    public int loadTexture(Resources res,AssetManager assetMngr) {

        getPathType();
        if(pathType==isdirectory)
        {
            getMipMapPaths(assetMngr);
            if(compressionType==compression_ETC2 ||compressionType==compression_ETC1) {
                return loadCompressedETC2(res,assetMngr);
            }
            else {
                return loadTextureInternalUncompressed(res,assetMngr);
            }
        }
        else
        {
            String[] dotokens=path.split("[.]+");
            String extension="."+dotokens[dotokens.length-1].trim();

            if(extension.equals(".pkm"))
                compressionType=compression_ETC2;
            else
                compressionType=compression_NONE;

            if(compressionType==compression_ETC2 && mipmapping)
            {

                Logger.err("Texture "+path+" is compressed and mipmapping is requested, but path " +
                        "is not a directory that provides the mipmap images. Mipmaps cannot be autogenerated for compressed textures");
                return -1;
            }
            pathList=new String[1];
            pathList[0]=path;
            mipmaplevels=1;

            //at this point if the texture is compressed, mipmapping is disabled
            if(compressionType==compression_ETC2 ||compressionType==compression_ETC1) {
                return loadCompressedETC2(res,assetMngr);
            }
            else {
                return loadTextureInternalUncompressed(res,assetMngr);
            }
        }
    }

    /**
     * Mali texture compression tool outputs ETC1/ETC2 compressed textures
     */
    private int loadCompressedETC2(Resources res, AssetManager assetMngr) {
        this.glID = newTextureID();


        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, glID);

        if(!mipmapping) {
            if (interpolation == FILTER_LINEAR) {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR);
            } else {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_NEAREST);
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);
            }
        }
        else
        {
            if (interpolation == FILTER_LINEAR) {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR_MIPMAP_LINEAR);
            } else {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR_MIPMAP_NEAREST);
            }

            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER,GLES30.GL_LINEAR);
        }

        ETC2Util.ETC2Texture etctex=null;

        for (int i = 0; i < mipmaplevels; i++) {
            String path=pathList[i];
            try {
                etctex = ETC2Util.createTexture(assetMngr.open(path));
            } catch (IOException e) {
                e.printStackTrace();
                Logger.err(e.toString());
            }
            width = etctex.getWidth();
            height = etctex.getHeight();
            int datasize=etctex.getData().remaining();

            GLES30.glCompressedTexImage2D(GLES30.GL_TEXTURE_2D, i, etctex.getCompressionFormat(), etctex.getWidth(), etctex.getHeight(),
                    0, etctex.getData().remaining(), etctex.getData());
        }
        return glID;
    }

    private int loadTextureInternalUncompressed(Resources res,AssetManager am) {

        this.glID = newTextureID();
        GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, glID);

        if(!mipmapping) {
            if (interpolation == FILTER_LINEAR) {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR);
            } else {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_NEAREST);
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);
            }
        }
        else
        {
            if (interpolation == FILTER_LINEAR) {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR_MIPMAP_LINEAR);
            } else {
                GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR_MIPMAP_NEAREST);//bilineal
            }

            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER,GLES30.GL_LINEAR);
        }

        if (wrapMode == WRAP_CLAMP) {
            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_CLAMP_TO_EDGE);
            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_CLAMP_TO_EDGE);
        } else {
            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_REPEAT);
            GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_REPEAT);
        }


        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inScaled = false; //Disables android's automatic scaling of images

        /*
         * Disables bitmapfactory alpha channel premultiplication:
         * Useful for images with an alpha channel that aren't used as actual images but as data of
         * some kind (like a splatmap)
         */
        if(!preMultiplyAlpha)
            opts.inPremultiplied = false;
        Bitmap temp = null;

        for (int i = 0; i < mipmaplevels; i++) {

            try {
                temp = BitmapFactory.decodeStream(am.open(pathList[i]),null,opts);
            } catch (IOException e) {
                e.printStackTrace();
            }

            temp.setPremultiplied(false);

            height = temp.getHeight();
            width = temp.getWidth();

            if (needsPixels && i==0) {
                pixels = new int[width * height];
                temp.getPixels(pixels, 0, width, 0, 0, width, height);
            }

            //get the pixel buffer
            ByteBuffer pixelbuf = ByteBuffer.allocateDirect(width * height * IntBytes);
            pixelbuf.order(ByteOrder.nativeOrder());
            temp.copyPixelsToBuffer(pixelbuf);
            pixelbuf.position(0);
            int internalFormat = GLUtils.getInternalFormat(temp); //like GLES30.RGBA
            int type = GLUtils.getType(temp); //i.e GLES30.UNSIGNED_BYTE

            GLES30.glTexImage2D(GLES30.GL_TEXTURE_2D, i, internalFormat, width, height, 0, internalFormat, type, pixelbuf);
        }

        //autogen mipmaps if they were requested but not provided
        if(mipmapping && pathType!=isdirectory)
            GLES30.glGenerateMipmap(GLES30.GL_TEXTURE_2D);

        temp.recycle();
        return glID;
    }

    public float getVal(int x, int y) {
        int color = Color.red(pixels[x + y * width]);
        return (float) color / 255f;
    }

    public Vec2f minMaxValArea(float x, float z, float w, float h) {
        float maxVal = -Float.MAX_VALUE;
        float minVal = Float.MAX_VALUE;
        //convert world normalized coords to local texture coords

        x *= width;
        z *= height;
        w *= width;
        h *= height;

        for (float i = x; i < x + w; i++)
            for (float j = z; j < z + h; j++) {

                float newVal = getVal((int)i, (int)j);

                if (newVal > maxVal) {
                    maxVal = newVal;
                }
                if (newVal < minVal) {
                    minVal = newVal;
                }
            }
        return new Vec2f(maxVal, minVal);
    }

    public void freepixels() {
        pixels = null;
    }

    public int getHeight() {
        return height;
    }

    public int getWidth() {
        return width;
    }

    @Override
    public int getGlID() {
        return glID;
    }
}
